{"version":3,"sources":["../src/span.js"],"names":[],"mappings":"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","file":"span.js","sourcesContent":["import * as noop from './noop';\n\n/**\n * Span represents a logical unit of work as part of a broader Trace. Examples\n * of span might include remote procedure calls or a in-process function calls\n * to sub-components. A Trace has a single, top-level \"root\" Span that in turn\n * may have zero or more child Spans, which in turn may have children.\n */\nexport default class Span {\n\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Returns the SpanContext object associated with this Span.\n     *\n     * @return {SpanContext}\n     */\n    context() {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 0) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n\n        return this._context();\n    }\n\n\n    /**\n     * Returns the Tracer object used to create this Span.\n     *\n     * @return {Tracer}\n     */\n    tracer() {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 0) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n\n        return this._tracer();\n    }\n\n    /**\n     * Sets the string name for the logical operation this span represents.\n     *\n     * @param {string} name\n     */\n    setOperationName(name) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof name !== 'string' || name.length === 0) {\n                throw new Error('Name must be a string of length > 0');\n            }\n        }\n\n        this._setOperationName(name);\n        return this;\n    }\n\n    /**\n     * Sets a key:value pair on this Span that also propagates to future\n     * children of the associated Span.\n     *\n     * setBaggageItem() enables powerful functionality given a full-stack\n     * opentracing integration (e.g., arbitrary application data from a web\n     * client can make it, transparently, all the way into the depths of a\n     * storage system), and with it some powerful costs: use this feature with\n     * care.\n     *\n     * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to\n     * *future* causal descendants of the associated Span.\n     *\n     * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and\n     * value is copied into every local *and remote* child of the associated\n     * Span, and that can add up to a lot of network and cpu overhead.\n     *\n     * @param {string} key\n     * @param {string} value\n     */\n    setBaggageItem(key, value) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n\n        this._setBaggageItem(key, value);\n        return this;\n    }\n\n    /**\n     * Returns the value for a baggage item given its key.\n     *\n     * @param  {string} key\n     *         The key for the given trace attribute.\n     * @return {string}\n     *         String value for the given key, or undefined if the key does not\n     *         correspond to a set trace attribute.\n     */\n    getBaggageItem(key) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n\n        return this._getBaggageItem(key);\n    }\n\n    /**\n     * Adds a single tag to the span.  See `addTags()` for details.\n     *\n     * @param {string} key\n     * @param {any} value\n     */\n    setTag(key, value) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof key !== 'string') {\n                throw new Error('Tag key must be a string');\n            }\n        }\n\n        // NOTE: the call is normalized to a call to _addTags()\n        this._addTags({ [key] : value });\n        return this;\n    }\n\n    /**\n     * Adds the given key value pairs to the set of span tags.\n     *\n     * Multiple calls to addTags() results in the tags being the superset of\n     * all calls.\n     *\n     * The behavior of setting the same key multiple times on the same span\n     * is undefined.\n     *\n     * The supported type of the values is implementation-dependent.\n     * Implementations are expected to safely handle all types of values but\n     * may choose to ignore unrecognized / unhandle-able values (e.g. objects\n     * with cyclic references, function objects).\n     *\n     * @return {[type]} [description]\n     */\n    addTags(keyValueMap) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof keyValueMap !== 'object') {\n                throw new Error('Invalid argument type');\n            }\n        }\n\n        this._addTags(keyValueMap);\n        return this;\n    }\n\n    /**\n     * Explicitly create a log record associated with the span.\n     *\n     * @param {object} fields - object containing the log record properties\n     * @param {number} [fields.timestamp] - optional field specifying the\n     *        timestamp in milliseconds as a Unix timestamp. Fractional values\n     *        are allowed so that timestamps with sub-millisecond accuracy\n     *        can be represented. If not specified, the implementation is\n     *        expected to use it's notion of the current time of the call.\n     * @param {string} [fields.event] - the event name\n     * @param {object} [fields.payload] - an arbitrary structured payload. It is\n     *        implementation-dependent how this will be processed.\n     */\n    log(fields) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof fields !== 'object') {\n                throw new Error('Expected fields to be an object');\n            }\n        }\n\n        this._log(fields);\n        return this;\n    }\n\n    /**\n     * Logs a event with an optional payload.\n     *\n     * @param  {string} eventName - string associated with the log record\n     * @param  {object} [payload] - arbitrary payload object associated with the\n     *         log record.\n     */\n    logEvent(eventName, payload) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length >= 1 && arguments.length <= 2) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof eventName !== 'string') {\n                throw new Error('Expected eventName to be a string');\n            }\n            if (payload !== undefined && typeof payload !== 'object') {\n                throw new Error('Expected payload to be an object');\n            }\n        }\n\n        return this._log({\n            event   : eventName,\n            payload : payload,\n        });\n    }\n\n    /**\n     * Sets the end timestamp and finalizes Span state.\n     *\n     * With the exception of calls to Span.context() (which are always allowed),\n     * finish() must be the last call made to any span instance, and to do\n     * otherwise leads to undefined behavior.\n     *\n     * @param  {Number} finishTime\n     *         Optional finish time in milliseconds as a Unix timestamp. Decimal\n     *         values are supported for timestamps with sub-millisecond accuracy.\n     *         If not specified, the current time (as defined by the\n     *         implementation) will be used.\n     */\n    finish(finishTime) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 1) {\n                throw new Error('Invalid arguments');\n            }\n            if (arguments.length === 1 && typeof finishTime !== 'number') {\n                throw new Error('Unexpected argument type');\n            }\n        }\n\n        this._finish(finishTime);\n\n        // Do not return `this`. The Span generally should not be used after it\n        // is finished so chaining is not desired in this context.\n    }\n\n\n    // ---------------------------------------------------------------------- //\n    // Methods derived classes can choose to implement\n    // ---------------------------------------------------------------------- //\n\n    // By default returns a no-op SpanContext.\n    _context() {\n        return noop.spanContext;\n    }\n\n    // By default returns a no-op tracer.\n    //\n    // The base class could store the tracer that created it, but it does not\n    // in order to ensure the no-op span implementation has zero members,\n    // which allows V8 to aggressively optimize calls to such objects.\n    _tracer() {\n        return noop.tracer;\n    }\n\n    // By default does nothing\n    _setOperationName(name) {\n    }\n\n    // By default does nothing\n    _setBaggageItem(key, value) {\n    }\n\n    // By default does nothing\n    _getBaggageItem(key) {\n    }\n\n    // By default does nothing\n    //\n    // NOTE: both setTag() and addTags() map to this function. keyValuePairs\n    // will always be an associative array.\n    _addTags(keyValuePairs) {\n    }\n\n    // By default does nothing\n    //\n    // NOTE: both log() and logEvent() map to this function. fields will always\n    // be an associative array.\n    _log(fields) {\n    }\n\n    // By default does nothing\n    //\n    // finishTime is expected to be either a number or undefined.\n    _finish(finishTime) {\n    }\n}\n"]}