{"version":3,"sources":["../src/span_context.js"],"names":[],"mappings":"AAAA;;AAEA;;;;;;;;;;;;;;;;;;;IAUqB,W;;;;;AAEjB;;;;;;;;;;;;;;;;;;;;uCAoBe,G,EAAK,K,EAAO;AAMvB,gBAAI,KAAK,IAAT,EAAe;AACX,qBAAK,IAAL,CAAU,cAAV,CAAyB,GAAzB,EAA8B,KAA9B;AACH;AACJ;;AAED;;;;;;;;;;;;uCASe,G,EAAK;AAMhB,gBAAI,KAAK,IAAT,EAAe;AACX,uBAAO,KAAK,IAAL,CAAU,cAAV,CAAyB,GAAzB,CAAP;AACH;AACD,mBAAO,SAAP;AACH;;AAED;;;;;;;;;AAMA,yBAAY,GAAZ,EAAiB;AAAA;;AACb,aAAK,IAAL,GAAY,GAAZ;AACH;;AAED;;;;;;;;8BAIM;AACF,mBAAO,KAAK,IAAZ;AACH;;;;;;kBAtEgB,W","file":"span_context.js","sourcesContent":["'use strict';\n\n/**\n * SpanContext represents Span state that must propagate to descendant Spans\n * and across process boundaries.\n *\n * SpanContext is logically divided into two pieces: the user-level \"Baggage\"\n * (see setBaggageItem and getBaggageItem) that propagates across Span\n * boundaries and any Tracer-implementation-specific fields that are needed to\n * identify or otherwise contextualize the associated Span instance (e.g., a\n * <trace_id, span_id, sampled> tuple).\n */\nexport default class SpanContext {\n\n    /**\n     * Sets a key:value pair on this SpanContext that also propagates to future\n     * children of the associated Span.\n     *\n     * setBaggageItem() enables powerful functionality given a full-stack\n     * opentracing integration (e.g., arbitrary application data from a web\n     * client can make it, transparently, all the way into the depths of a\n     * storage system), and with it some powerful costs: use this feature with\n     * care.\n     *\n     * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to\n     * *future* causal descendants of the associated Span.\n     *\n     * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and\n     * value is copied into every local *and remote* child of the associated\n     * Span, and that can add up to a lot of network and cpu overhead.\n     *\n     * @param {string} key\n     * @param {string} value\n     */\n    setBaggageItem(key, value) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n        if (this._imp) {\n            this._imp.setBaggageItem(key, value);\n        }\n    }\n\n    /**\n     * Returns the value for a baggage item given its key.\n     *\n     * @param  {string} key\n     *         The key for the given trace attribute.\n     * @return {string}\n     *         String value for the given key, or undefined if the key does not\n     *         correspond to a set trace attribute.\n     */\n    getBaggageItem(key) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n        if (this._imp) {\n            return this._imp.getBaggageItem(key);\n        }\n        return undefined;\n    }\n\n    /**\n     * Constructs a new SpanContext object.\n     *\n     * This method should not be called directly; Span.context() should be used\n     * instead.\n     */\n    constructor(imp) {\n        this._imp = imp;\n    }\n\n    /**\n     * Returns the SpanContext implementation object. The returned object is by\n     * its nature entirely implementation-dependent.\n     */\n    imp() {\n        return this._imp;\n    }\n}\n"]}