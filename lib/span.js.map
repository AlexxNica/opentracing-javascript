{"version":3,"sources":["../src/span.js"],"names":[],"mappings":"AAAA;;;;;;;;;;AAEA;;;;AACA;;;;;;;;;;AACA,IAAI,gBAAgB,QAAQ,kBAAR,CAApB;;AAEA;;;;;;;IAMqB,I;;;;;AAEjB;AACA;AACA;;AAEA;;;;;kCAKU;AAMN,gBAAI,iBAAiB,IAArB;AACA,gBAAI,KAAK,IAAT,EAAe;AACX,iCAAiB,KAAK,IAAL,CAAU,OAAV,EAAjB;AACH;AACD,mBAAO,2BAAgB,cAAhB,CAAP;AACH;;AAED;;;;;;;;iCAKS;AAML,gBAAI,KAAK,IAAT,EAAe;AACX,uBAAO,qBAAW,KAAK,IAAL,CAAU,MAAV,EAAX,CAAP;AACH;AACD,mBAAO,aAAP;AACH;;AAED;;;;;;;;yCAKiB,I,EAAM;AASnB,gBAAI,KAAK,IAAT,EAAe;AACX,qBAAK,IAAL,CAAU,gBAAV,CAA2B,IAA3B;AACH;AACD,mBAAO,IAAP;AACH;;AAED;;;;;;;;;+BAMO,G,EAAK,K,EAAO;AASf,iBAAK,OAAL,qBAAgB,GAAhB,EAAuB,KAAvB;AACA,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;gCAgBQ,a,EAAe;;AAUnB,gBAAI,CAAC,KAAK,IAAV,EAAgB;AACZ;AACH;AACD,iBAAK,IAAL,CAAU,OAAV,CAAkB,aAAlB;AACA,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;;;;;;;4BAaI,M,EAAQ;AASR,gBAAI,CAAC,KAAK,IAAV,EAAgB;AACZ;AACH;AACD,iBAAK,IAAL,CAAU,GAAV,CAAc,MAAd;AACA,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;iCAOS,S,EAAW,O,EAAS;AACzB,mBAAO,KAAK,GAAL,CAAS;AACZ,uBAAU,SADE;AAEZ,yBAAU;AAFE,aAAT,CAAP;AAIH;;AAED;;;;;;;;;;;;;;;;+BAaO,U,EAAY;;AAUf,gBAAI,CAAC,KAAK,IAAV,EAAgB;AACZ;AACH;AACD,iBAAK,IAAL,CAAU,MAAV,CAAiB,UAAjB;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;uCAoBe,G,EAAK,K,EAAO;AAMvB,gBAAI,KAAK,IAAT,EAAe;AACX,qBAAK,IAAL,CAAU,cAAV,CAAyB,GAAzB,EAA8B,KAA9B;AACH;AACJ;;AAED;;;;;;;;;;;;uCASe,G,EAAK;AAMhB,gBAAI,KAAK,IAAT,EAAe;AACX,uBAAO,KAAK,IAAL,CAAU,cAAV,CAAyB,GAAzB,CAAP;AACH;AACD,mBAAO,SAAP;AACH;;AAED;AACA;AACA;;AAEA;;;;;;;AAIA,kBAAY,GAAZ,EAAiB;AAAA;;AACb,aAAK,IAAL,GAAY,GAAZ;AACH;;AAED;;;;;;;;8BAIM;AACF,mBAAO,KAAK,IAAZ;AACH;;;;;;kBA/PgB,I","file":"span.js","sourcesContent":["'use strict';\n\nimport Tracer from './tracer';\nimport SpanContext from './span_context';\nlet defaultTracer = require('./default_tracer');\n\n/**\n * Span represents a logical unit of work as part of a broader Trace. Examples\n * of span might include remote procedure calls or a in-process function calls\n * to sub-components. A Trace has a single, top-level \"root\" Span that in turn\n * may have zero or more child Spans, which in turn may have children.\n */\nexport default class Span {\n\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Returns the SpanContext object associated with this Span.\n     *\n     * @return {SpanContext}\n     */\n    context() {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 0) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n        let spanContextImp = null;\n        if (this._imp) {\n            spanContextImp = this._imp.context();\n        }\n        return new SpanContext(spanContextImp);\n    }\n\n    /**\n     * Returns the Tracer object used to create this Span.\n     *\n     * @return {Tracer}\n     */\n    tracer() {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 0) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n        if (this._imp) {\n            return new Tracer(this._imp.tracer());\n        }\n        return defaultTracer;\n    }\n\n    /**\n     * Sets the string name for the logical operation this span represents.\n     *\n     * @param {string} name\n     */\n    setOperationName(name) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof name !== 'string' || name.length === 0) {\n                throw new Error('Name must be a string of length > 0');\n            }\n        }\n        if (this._imp) {\n            this._imp.setOperationName(name);\n        }\n        return this;\n    }\n\n    /**\n     * Adds a single tag to the span.  See `AddTags()` for details.\n     *\n     * @param {string} key\n     * @param {any} value\n     */\n    setTag(key, value) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof key !== 'string') {\n                throw new Error('Tag key must be a string');\n            }\n        }\n        this.addTags({ [key] : value });\n        return this;\n    }\n\n    /**\n     * Adds the given key value pairs to the set of span tags.\n     *\n     * Multiple calls to addTags() results in the tags being the superset of\n     * all calls.\n     *\n     * The behavior of setting the same key multiple times on the same span\n     * is undefined.\n     *\n     * The supported type of the values is implementation-dependent.\n     * Implementations are expected to safely handle all types of values but\n     * may choose to ignore unrecognized / unhandle-able values (e.g. objects\n     * with cyclic references, function objects).\n     *\n     * @return {[type]} [description]\n     */\n    addTags(keyValuePairs) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof keyValuePairs !== 'object') {\n                throw new Error('Invalid argument type');\n            }\n        }\n\n        if (!this._imp) {\n            return;\n        }\n        this._imp.addTags(keyValuePairs);\n        return this;\n    }\n\n    /**\n     * Explicitly create a log record associated with the span.\n     *\n     * @param {object} fields - object containing the log record properties\n     * @param {number} [fields.timestamp] - optional field specifying the\n     *        timestamp in milliseconds as a Unix timestamp. Fractional values\n     *        are allowed so that timestamps with sub-millisecond accuracy\n     *        can be represented. If not specified, the implementation is\n     *        expected to use it's notion of the current time of the call.\n     * @param {string} [fields.event] - the event name\n     * @param {object} [fields.payload] - an arbitrary structured payload. It is\n     *        implementation-dependent how this will be processed.\n     */\n    log(fields) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof fields !== 'object') {\n                throw new Error('Expected fields to be an object');\n            }\n        }\n        if (!this._imp) {\n            return;\n        }\n        this._imp.log(fields);\n        return this;\n    }\n\n    /**\n     * Logs a event with an optional payload.\n     *\n     * @param  {string} eventName - string associated with the log record\n     * @param  {object} [payload] - arbitrary payload object associated with the\n     *         log record.\n     */\n    logEvent(eventName, payload) {\n        return this.log({\n            event   : eventName,\n            payload : payload,\n        });\n    }\n\n    /**\n     * Sets the end timestamp and finalizes Span state.\n     *\n     * With the exception of calls to Span.context() (which are always allowed),\n     * finish() must be the last call made to any span instance, and to do\n     * otherwise leads to undefined behavior.\n     *\n     * @param  {Number} finishTime\n     *         Optional finish time in milliseconds as a Unix timestamp. Decimal\n     *         values are supported for timestamps with sub-millisecond accuracy.\n     *         If not specified, the current time (as defined by the\n     *         implementation) will be used.\n     */\n    finish(finishTime) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 1) {\n                throw new Error('Invalid arguments');\n            }\n            if (arguments.length === 1 && typeof finishTime !== 'number') {\n                throw new Error('Unexpected argument type');\n            }\n        }\n\n        if (!this._imp) {\n            return;\n        }\n        this._imp.finish(finishTime);\n    }\n\n    /**\n     * Sets a key:value pair on this Span that also propagates to future\n     * children of the associated Span.\n     *\n     * setBaggageItem() enables powerful functionality given a full-stack\n     * opentracing integration (e.g., arbitrary application data from a web\n     * client can make it, transparently, all the way into the depths of a\n     * storage system), and with it some powerful costs: use this feature with\n     * care.\n     *\n     * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to\n     * *future* causal descendants of the associated Span.\n     *\n     * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and\n     * value is copied into every local *and remote* child of the associated\n     * Span, and that can add up to a lot of network and cpu overhead.\n     *\n     * @param {string} key\n     * @param {string} value\n     */\n    setBaggageItem(key, value) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n        if (this._imp) {\n            this._imp.setBaggageItem(key, value);\n        }\n    }\n\n    /**\n     * Returns the value for a baggage item given its key.\n     *\n     * @param  {string} key\n     *         The key for the given trace attribute.\n     * @return {string}\n     *         String value for the given key, or undefined if the key does not\n     *         correspond to a set trace attribute.\n     */\n    getBaggageItem(key) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n        if (this._imp) {\n            return this._imp.getBaggageItem(key);\n        }\n        return undefined;\n    }\n\n    // ---------------------------------------------------------------------- //\n    // Private and non-standard methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Constructs a new Span object, this method should not be called directly;\n     * Tracer.startSpan() or Tracer.join() should be used instead.\n     */\n    constructor(imp) {\n        this._imp = imp;\n    }\n\n    /**\n     * Returns the Span implementation object. The returned object is by its\n     * nature entirely implementation-dependent.\n     */\n    imp() {\n        return this._imp;\n    }\n}\n"]}