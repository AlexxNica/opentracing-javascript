{"version":3,"sources":["../src/tracer.js"],"names":[],"mappings":"AAAA;;;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;AAEA;;;;;;IAMqB,M;;;;;AAEjB;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAqCU,Y,EAAc,M,EAAQ;;AAwB5B,gBAAI,UAAU,IAAd;AACA,gBAAI,KAAK,IAAT,EAAe;AACX;AACA;AACA,oBAAI,UAAU,MAAV,KAAqB,CAAzB,EAA4B;AACxB,wBAAI,OAAO,YAAP,KAAwB,QAA5B,EAAsC;AAClC,iCAAS;AACL,2CAAgB;AADX,yBAAT;AAGH,qBAJD,MAIO;AACH,iCAAS,YAAT;AACH;AACJ,iBARD,MAQO;AACH,2BAAO,aAAP,GAAuB,YAAvB;AACH;;AAYD;AACA,oBAAI,OAAO,OAAX,EAAoB;AAChB;AACA,wBAAI,UAAU,KAAK,OAAL,CAAa,OAAO,OAApB,CAAd;AACA,wBAAI,OAAO,UAAX,EAAuB;AACnB,+BAAO,UAAP,CAAkB,IAAlB,CAAuB,OAAvB;AACH,qBAFD,MAEO;AACH,+BAAO,UAAP,GAAoB,CAAC,OAAD,CAApB;AACH;AACD,2BAAO,OAAO,OAAd;AACH;AACD,0BAAU,KAAK,IAAL,CAAU,SAAV,CAAoB,MAApB,CAAV;AACH;AACD,mBAAO,mBAAS,OAAT,CAAP;AACH;;AAED;;;;;;;;;;gCAOQ,W,EAAa;AACjB,mBAAO,wBAAc,oBAAU,kBAAxB,EAA4C,WAA5C,CAAP;AACH;;AAED;;;;;;;;;;oCAOY,W,EAAa;AACrB,mBAAO,wBAAc,oBAAU,sBAAxB,EAAgD,WAAhD,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BA6BO,W,EAAa,M,EAAQ,O,EAAS;;AAsBjC,gBAAI,KAAK,IAAT,EAAe;AACX;AACA,oBAAI,qCAAJ,EAAiC;AAC7B,kCAAc,YAAY,OAAZ,EAAd;AACH;AACD,qBAAK,IAAL,CAAU,MAAV,CAAiB,YAAY,IAA7B,EAAmC,MAAnC,EAA2C,OAA3C;AACH;AACJ;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;gCAsBQ,M,EAAQ,O,EAAS;AAoBrB,gBAAI,iBAAiB,IAArB;AACA,gBAAI,KAAK,IAAT,EAAe;AACX,iCAAiB,KAAK,IAAL,CAAU,OAAV,CAAkB,MAAlB,EAA0B,OAA1B,CAAjB;AACH;AACD,gBAAI,mBAAmB,IAAvB,EAA6B;AACzB,uBAAO,2BAAgB,cAAhB,CAAP;AACH;AACD,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;;8BAQM,I,EAAM;AASR,gBAAI,CAAC,KAAK,IAAV,EAAgB;AACZ,qBAAK,IAAL;AACA;AACH;AACD,iBAAK,IAAL,CAAU,KAAV,CAAgB,IAAhB;AACH;;AAGD;AACA;AACA;;AAEA;;;;;;;AAIA,oBAAY,GAAZ,EAAiB;AAAA;;AACb,aAAK,IAAL,GAAY,OAAO,IAAnB;AACH;;AAED;;;;;;;;;;;;;;8BAUM;AACF,mBAAO,KAAK,IAAZ;AACH;;;;;;kBApSgB,M","file":"tracer.js","sourcesContent":["'use strict';\n\nimport Span from './span';\nimport SpanContext from './span_context';\nimport Constants from './constants';\nimport Reference from './reference';\n\n/**\n * Tracer is the entry-point between the instrumentation API and the tracing\n * implementation.\n *\n * The default object acts as a no-op implementation.\n */\nexport default class Tracer {\n\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Starts and returns a new Span representing a logical unit of work.\n     *\n     * For example:\n     *\n     *     // Start a new (parentless) root Span:\n     *     var parent = Tracer.startSpan('DoWork');\n     *\n     *     // Start a new (child) Span:\n     *     var child = Tracer.startSpan('Subroutine', {\n     *         reference: Tracer.childOf(parent.context()),\n     *     });\n     *\n     * @param {string|object} nameOrFields - if the given argument is a\n     *        string, it is the name of the operation and the second `fields`\n     *        argument is optional. If it is an object, it is treated as the\n     *        fields argument and a second argument should not be provided.\n     * @param {object} [fields] - the fields to set on the newly created span.\n     * @param {string} [fields.operationName] - the name to use for the newly\n     *        created span. Required if called with a single argument.\n     * @param {SpanContext} [fields.childOf] - a parent SpanContext (or Span,\n     *        for convenience) that the newly-started span will be the child of\n     *        (per REFERENCE_CHILD_OF). If specified, `fields.references` must\n     *        be unspecified.\n     * @param {array} [fields.references] - an array of Reference instances,\n     *        each pointing to a causal parent SpanContext. If specified,\n     *        `fields.childOf` must be unspecified.\n     * @param {object} [fields.tags] - set of key-value pairs which will be set\n     *        as tags on the newly created Span. Ownership of the object is\n     *        passed to the created span for efficiency reasons (the caller\n     *        should not modify this object after calling startSpan).\n     * @param {number} [fields.startTime] - a manually specified start time for\n     *        the created Span object. The time should be specified in\n     *        milliseconds as Unix timestamp. Decimal value are supported\n     *        to represent time values with sub-millisecond accuracy.\n     * @return {Span} - a new Span object.\n     */\n    startSpan(nameOrFields, fields) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 2) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (typeof nameOrFields !== 'string' && typeof nameOrFields !== 'object') {\n                throw new Error('argument expected to be a string or object');\n            }\n            if (typeof nameOrFields === 'string' && nameOrFields.length === 0) {\n                throw new Error('operation name cannot be length zero');\n            }\n            if (typeof nameOrFields === 'object') {\n                if (arguments.length !== 1) {\n                    throw new Error('Unexpected number of arguments');\n                }\n                if (nameOrFields === null) {\n                    throw new Error('fields should not be null');\n                }\n                if (!nameOrFields.operationName) {\n                    throw new Error('operationName is a required parameter');\n                }\n            }\n        }\n\n        let spanImp = null;\n        if (this._imp) {\n            // Normalize the argument so the implementation is always provided\n            // an associative array of fields.\n            if (arguments.length === 1) {\n                if (typeof nameOrFields === 'string') {\n                    fields = {\n                        operationName : nameOrFields,\n                    };\n                } else {\n                    fields = nameOrFields;\n                }\n            } else {\n                fields.operationName = nameOrFields;\n            }\n            if (process.env.NODE_ENV === 'debug') {\n                if (fields.childOf && fields.references) {\n                    throw new Error('At most one of `childOf` and ' +\n                            '`references` may be specified');\n                }\n                if (fields.childOf && !(\n                            fields.childOf instanceof Span ||\n                            fields.childOf instanceof SpanContext)) {\n                    throw new Error('childOf must be a Span or SpanContext instance');\n                }\n            }\n            // Convert fields.childOf to fields.references as needed.\n            if (fields.childOf) {\n                // Convert from a Span or a SpanContext into a Reference.\n                let childOf = this.childOf(fields.childOf);\n                if (fields.references) {\n                    fields.references.push(childOf);\n                } else {\n                    fields.references = [childOf];\n                }\n                delete(fields.childOf);\n            }\n            spanImp = this._imp.startSpan(fields);\n        }\n        return new Span(spanImp);\n    }\n\n    /**\n     * Return a new REFERENCE_CHILD_OF reference.\n     *\n     * @param {SpanContext} spanContext - the parent SpanContext instance to\n     *        reference.\n     * @return a REFERENCE_CHILD_OF reference pointing to `spanContext`\n     */\n    childOf(spanContext) {\n        return new Reference(Constants.REFERENCE_CHILD_OF, spanContext);\n    }\n\n    /**\n     * Return a new REFERENCE_FOLLOWS_FROM reference.\n     *\n     * @param {SpanContext} spanContext - the parent SpanContext instance to\n     *        reference.\n     * @return a REFERENCE_FOLLOWS_FROM reference pointing to `spanContext`\n     */\n    followsFrom(spanContext) {\n        return new Reference(Constants.REFERENCE_FOLLOWS_FROM, spanContext);\n    }\n\n    /**\n     * Injects the given SpanContext instance for cross-process propagation\n     * within `carrier`. The expected type of `carrier` depends on the value of\n     * `format.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     var clientSpan = ...;\n     *     ...\n     *     // Inject clientSpan into a text carrier.\n     *     var headersCarrier = {};\n     *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     // Incorporate the textCarrier into the outbound HTTP request header\n     *     // map.\n     *     Object.assign(outboundHTTPReq.headers, headersCarrier);\n     *     // ... send the httpReq\n     *\n     * @param  {SpanContext} spanContext - the SpanContext to inject into the\n     *         carrier object. As a convenience, a Span instance may be passed\n     *         in instead (in which case its .context() is used for the\n     *         inject()).\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - see the documentation for the chosen `format`\n     *         for a description of the carrier object.\n     */\n    inject(spanContext, format, carrier) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 3) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (!(spanContext instanceof SpanContext || spanContext instanceof Span)) {\n                throw new Error('first argument must be a SpanContext or Span instance');\n            }\n            if (typeof format !== 'string') {\n                throw new Error(`format expected to be a string. Found: ${typeof format}`);\n            }\n            if (format === Constants.FORMAT_TEXT_MAP && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_TEXT_MAP');\n            }\n            if (format === Constants.FORMAT_HTTP_HEADERS && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_HTTP_HEADERS');\n            }\n            if (format === Constants.FORMAT_BINARY && typeof carrier !== 'object') {\n                throw new Error('Unexpected carrier object for FORMAT_BINARY');\n            }\n        }\n\n        if (this._imp) {\n            // Allow the user to pass a Span instead of a SpanContext\n            if (spanContext instanceof Span) {\n                spanContext = spanContext.context();\n            }\n            this._imp.inject(spanContext._imp, format, carrier);\n        }\n    }\n\n    /**\n     * Returns a SpanContext instance extracted from `carrier` in the given\n     * `format`.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     // Use the inbound HTTP request's headers as a text map carrier.\n     *     var headersCarrier = inboundHTTPReq.headers;\n     *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });\n     *\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - the type of the carrier object is determined by\n     *         the format.\n     * @return {SpanContext}\n     *         The extracted SpanContext, or null if no such SpanContext could\n     *         be found in `carrier`\n     */\n    extract(format, carrier) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments.');\n            }\n            if (typeof format !== 'string' || !format.length) {\n                throw new Error('format is expected to be a string of non-zero length');\n            }\n            if (format === Constants.FORMAT_TEXT_MAP && !(typeof carrier === 'object')) {\n                throw new Error('Unexpected carrier object for FORMAT_TEXT_MAP');\n            }\n            if (format === Constants.FORMAT_HTTP_HEADERS && !(typeof carrier === 'object')) {\n                throw new Error('Unexpected carrier object for FORMAT_HTTP_HEADERS');\n            }\n            if (format === Constants.FORMAT_BINARY) {\n                if (carrier.buffer !== undefined && typeof carrier.buffer !== 'object') {\n                    throw new Error('Unexpected carrier object for FORMAT_BINARY');\n                }\n            }\n        }\n        let spanContextImp = null;\n        if (this._imp) {\n            spanContextImp = this._imp.extract(format, carrier);\n        }\n        if (spanContextImp !== null) {\n            return new SpanContext(spanContextImp);\n        }\n        return null;\n    }\n\n    /**\n     * Request that any buffered or in-memory data is flushed out of the process.\n     *\n     * @param {function(err: objectg)} done - optional callback function with\n     *        the signature `function(err)` that will be called as soon as the\n     *        flush completes. `err` should be null or undefined if the flush\n     *        was successful.\n     */\n    flush(done) {\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (done !== undefined && typeof done !== 'function') {\n                throw new Error('callback expected to be a function');\n            }\n        }\n        if (!this._imp) {\n            done(null);\n            return;\n        }\n        this._imp.flush(done);\n    }\n\n\n    // ---------------------------------------------------------------------- //\n    // Private and non-standard methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Note: this constructor should not be called directly by consumers of this\n     * code. The singleton's initNewTracer() method should be invoked instead.\n     */\n    constructor(imp) {\n        this._imp = imp || null;\n    }\n\n    /**\n     * Handle to implementation object.\n     *\n     * Use of this method is discouraged as it greatly reduces the portability of\n     * the calling code. Use only when implementation-specific functionality must\n     * be used and cannot accessed otherwise.\n     *\n     * @return {object}\n     *         An implementation-dependent object.\n     */\n    imp() {\n        return this._imp;\n    }\n}\n"]}